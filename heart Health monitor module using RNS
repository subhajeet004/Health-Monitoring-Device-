/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body for a fault-tolerant heart monitor
  * using a Residue Number System (RNS).
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h" // Main header from STM32CubeIDE
#include <stdio.h> // For printf debugging if you set up a UART
#include <stdbool.h>

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
// Struct to hold the RNS representation
typedef struct {
    uint16_t r1; // residue for M1
    uint16_t r2; // residue for M2
    uint16_t r3; // residue for M3 (redundant)
} RNS_Tuple;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
// --- RNS Configuration ---
// Chosen to handle a BPM range up to 13*17 = 221
const uint16_t M1 = 13;
const uint16_t M2 = 17;
const uint16_t M3_REDUNDANT = 19;
const uint16_t PLAUSIBLE_BPM_MIN = 40;
const uint16_t PLAUSIBLE_BPM_MAX = 220;

// --- BPM Calculation Configuration ---
const uint16_t ADC_PEAK_THRESHOLD = 2500; // Adjust this based on your sensor's output (0-4095 for 12-bit ADC)
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */
// ADC_HandleTypeDef hadc1; // Example: Assuming you're using ADC1. This is generated by CubeMX.
// UART_HandleTypeDef huart2; // Example: For printing debug info. Generated by CubeMX.

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
// --- RNS Function Prototypes ---
RNS_Tuple toRNS(uint16_t n);
int16_t findMinX(uint16_t num1, uint16_t rem1, uint16_t num2, uint16_t rem2);
int16_t correctRNS(RNS_Tuple tuple);

// --- Application Function Prototypes ---
uint16_t Read_Pulse_Sensor_ADC(void);
int16_t Calculate_BPM(void);
void Display_On_LCD(int16_t bpm_value);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* MCU Configuration--------------------------------------------------------*/
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();

  /* Initialize all configured peripherals (e.g., ADC, GPIO, UART) */
  // MX_GPIO_Init();
  // MX_ADC1_Init();
  // MX_USART2_UART_Init();

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* 1. Calculate the raw BPM from the sensor */
    int16_t raw_bpm = Calculate_BPM();

    /* 2. Process only when a new BPM value is available */
    if (raw_bpm > 0)
    {
        /* 3. Convert the critical BPM data to its RNS form */
        RNS_Tuple rns_bpm = toRNS(raw_bpm);

        /*
         * At this point, a hardware glitch or transient fault could
         * corrupt one of the residues (r1, r2, or r3) in memory.
         * The 'correctRNS' function is designed to handle this.
         */

        /* 4. Run the RNS check and correction algorithm */
        int16_t final_trusted_bpm = correctRNS(rns_bpm);

        /* 5. Display the final, reliable value */
        Display_On_LCD(final_trusted_bpm);
    }
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    HAL_Delay(10); // Small delay to prevent the loop from running too fast
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  // This function is generated automatically by STM32CubeIDE.
  // ...
}


/* USER CODE BEGIN 4 */

/**
  * @brief Reads the pulse sensor's analog value.
  * @note  **REPLACE THIS with your actual ADC reading code.**
  * @retval 12-bit ADC value (0-4095).
  */
uint16_t Read_Pulse_Sensor_ADC(void)
{
    // --- REAL IMPLEMENTATION ---
    // HAL_ADC_Start(&hadc1);
    // HAL_ADC_PollForConversion(&hadc1, 100); // Wait for conversion
    // return HAL_ADC_GetValue(&hadc1);

    // --- MOCK IMPLEMENTATION (for testing without a sensor) ---
    // This creates a simple sawtooth wave that peaks every ~800ms (~75 BPM)
    return (HAL_GetTick() % 800) * 5;
}

/**
  * @brief Detects heartbeats from the ADC signal and calculates BPM.
  * @retval A new BPM value if a beat is detected, otherwise 0.
  */
int16_t Calculate_BPM(void)
{
    static uint32_t last_peak_time_ms = 0;
    static bool is_peaking = false;
    int16_t new_bpm = 0;

    uint16_t adc_value = Read_Pulse_Sensor_ADC();
    uint32_t current_time_ms = HAL_GetTick(); // Get current time from system timer

    // Simple peak detection logic
    if (adc_value > ADC_PEAK_THRESHOLD && !is_peaking)
    {
        is_peaking = true; // Mark the beginning of a peak
        if (last_peak_time_ms > 0)
        {
            uint32_t time_between_beats = current_time_ms - last_peak_time_ms;
            // Calculate BPM: (60 seconds * 1000 ms/s) / ms_per_beat
            if (time_between_beats > 0) {
                 new_bpm = 60000 / time_between_beats;
            }
        }
        last_peak_time_ms = current_time_ms;
    }
    else if (adc_value < (ADC_PEAK_THRESHOLD - 500)) // Use a lower threshold to reset
    {
        is_peaking = false;
    }

    return new_bpm;
}

/**
  * @brief Converts a standard integer to its RNS representation.
  */
RNS_Tuple toRNS(uint16_t n) {
    RNS_Tuple tuple;
    tuple.r1 = n % M1;
    tuple.r2 = n % M2;
    tuple.r3 = n % M3_REDUNDANT;
    return tuple;
}

/**
  * @brief Helper function to solve a system of two congruences.
  * (Part of the Chinese Remainder Theorem)
  */
int16_t findMinX(uint16_t num1, uint16_t rem1, uint16_t num2, uint16_t rem2) {
    uint16_t x = rem1;
    for (int i = 0; i < num2; i++) {
        if (x % num2 == rem2) return x;
        x += num1;
    }
    return -1; // Error case
}

/**
  * @brief The core logic for detecting and correcting a single residue error.
  * @return The corrected integer value, or -1 if uncorrectable.
  */
int16_t correctRNS(RNS_Tuple tuple) {
    // Reconstruct using Pair A {M1, M2}
    int16_t val_A = findMinX(M1, tuple.r1, M2, tuple.r2);
    // Reconstruct using Pair B {M1, M3}
    int16_t val_B = findMinX(M1, tuple.r1, M3_REDUNDANT, tuple.r3);
    // Reconstruct using Pair C {M2, M3}
    int16_t val_C = findMinX(M2, tuple.r2, M3_REDUNDANT, tuple.r3);

    // Decision Logic: Find which two reconstructions agree and are plausible
    if (val_A == val_B && (val_A >= PLAUSIBLE_BPM_MIN && val_A <= PLAUSIBLE_BPM_MAX)) {
        return val_A;
    }
    if (val_A == val_C && (val_A >= PLAUSIBLE_BPM_MIN && val_A <= PLAUSIBLE_BPM_MAX)) {
        return val_A;
    }
    if (val_B == val_C && (val_B >= PLAUSIBLE_BPM_MIN && val_B <= PLAUSIBLE_BPM_MAX)) {
        return val_B;
    }

    // If no two results agree on a plausible BPM, the error is uncorrectable
    return -1;
}

/**
  * @brief Displays the final BPM value.
  * @note  **REPLACE THIS with your specific LCD or UART driver code.**
  */
void Display_On_LCD(int16_t bpm_value)
{
    // --- REAL IMPLEMENTATION EXAMPLE (for a 16x2 I2C LCD) ---
    // char buffer[16];
    // if (bpm_value != -1) {
    //   sprintf(buffer, "BPM: %3d   ", bpm_value);
    // } else {
    //   sprintf(buffer, "BPM: ERROR");
    // }
    // lcd_set_cursor(0, 0);
    // lcd_send_string(buffer);

    // --- MOCK IMPLEMENTATION (for UART debugging) ---
    // You must set up a UART (e.g., USART2) in CubeMX for this to work.
    char buffer[50];
    if (bpm_value != -1) {
      sprintf(buffer, "Final Trusted BPM: %d\r\n", bpm_value);
    } else {
      sprintf(buffer, "Final Trusted BPM: UNCORRECTABLE ERROR\r\n");
    }
    // HAL_UART_Transmit(&huart2, (uint8_t*)buffer, strlen(buffer), 100);
}

/* USER CODE END 4 */
